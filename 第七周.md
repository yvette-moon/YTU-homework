# 问题 A: C 语言习题 字符串排序      
   ## 题目描述
**输入 n 个字符串，将它们按字母由小到大的顺序排列并输出。编写三个函数实现，input 用于输入 n个字符串，sortstr 用于排序 n个字符串，output 用于输出 n个字符串**

输入:
第一行n第二行到第n+1行，每行一个字符串        
输出:
 排序后的字符串  
 
输入输出样例
样例输入:
```
 3
YTU
ACM
COM
```
 样例输出 :
```           
 ACM
COM
YTU
```            
提示
主函数已给定如下，提交时不需要包含下述主函数C:
```
int main()
{
    char str[10][10];
    int n;
    scanf("%d", &n);
    input(str, n);
    sortstr(str, n);
    output(str, n);
    return 0;
}
```
```
C++:
int main()
{
    string str[10];
    int n;
    cin >> n;
    input(str, n);
    sortstr(str, n);
    output(str, n);
    return 0;
}
```
### 详解

编写三个函数 input output sortstr

学习怎么处理字符串

给出的c++代码中用了字符串数组，我们利用for循环直接输入输出就好，sortstr则直接而用sort函数。

示例代码：
c++
```
#include <iostream>
#include <string>
#include <algorithm>
using namespace std;

void input(string str[10], int n) {
    for (int i=0; i<n;i++) {
        cin >> str[i];
    }
}

void sortstr(string str[10], int n) {
    sort(str, str + n);
}

void output(string str[10], int n) {
    for (int i = 0; i < n; i++) {
        cout << str[i] << endl;
    }
}
```
## 问题 B: 交换瓶子
### 题目描述
有N个瓶子，编号 1, 2... N，放在架子上。比如有 5 个瓶子：2 1 3 5 4要求每次拿起 2个瓶子，交换它们的位置。经过若干次后，使得瓶子的序号为：$1 2 3 4 5$对于这么简单的情况，显然，至少需要交换 $2$ 次就可以复位。如果瓶子更多呢？你可以通过编程来解决。

输入

第一行有一个正整数N (N< 10000), 表示瓶子的数目第二行有N个正整数，用空格分开，表示瓶子目前的排列情况。        

输出
        
输出数据为一行一个正整数，表示至少交换多少次，才能完成排序。    

输入输出样例 
输入
```
5
3 1 2 5 4
```
输出
```
3
```
### 详解
**贪心**
遇到不对的就把该位置的数和应该的数交换，比如说例子中，3的位置不对，应该的数字是1，把1和3交换，交换后得到1 3 2 5 4
难处理的地方在于，怎么找到应该的数并交换，一种方法是两个for循环，第一层找不适合的数，第二层找应该的数，找到后交换，计数器加一
```
#include<bits/stdc++.h>
using namespace std;
int main(){
    int n;
    int bottle[10005];
    cin>>n;
    for(int i=1;i<=n;i++){
        cin>>bottle[i];
    }
    int ans=0;
    for(int i=1;i<=n;i++){
        if(bottle[i]!=i){
            for(int j=i;j<=n;j++){
                if(bottle[j]==i){
                    swap(bottle[i],bottle[j]);
                    ans++;
                    break;
                }
            }
        }
       
    }
    cout<<ans;
    return 0;
}
```
OJ上可以通过，但是该方法时间复杂度高，要是n>10000就会超时
我们可以利用一个数组储存数字位置来减少时间复杂度
```
#include<bits/stdc++.h>
using namespace std;
int main(){
    int n;
    int bottle[10005];
    cin>>n;
    int pos[10005];
    for(int i=1;i<=n;i++){
        cin>>bottle[i];
        pos[bottle[i]]=i;
    }
    int ans=0;
    for(int i=1;i<=n;i++){
        if(bottle[i]!=i){
            swap(bottle[i],bottle[pos[i]]);
            pos[bottle[pos[i]]]=pos[i];
            pos[i]=i;
            ans++;
        }
       
    }
    cout<<ans;
    return 0;
}
```
OJ同样可通过，当然肯定还有别的好方法。
## 问题 C: 二分查找      
### 题目描述
**小 C 同学有 $n$ 个苹果，每个苹果的甜度都不相同，他现在想要吃一个甜度为 $a$ 的苹果，可他又不想一个个去找，聪明的你能帮他在最少次数 (相对次数最少) 内找出甜度为 $a$ 的苹果吗?**      
 输入
 第一行输入苹果的个数 $n$ ($0 \lt n \lt 300000$).下面 $n$ 行从小到大输入苹果的甜度。(保证没有重复）第 $n+2$ 行，输入需要找的苹果的甜度.        
输出
若找到，输出你寻找的次数。否则，输出 I can't find it.        
**输入输出样例**
               
样例输入 
```
5
1
2
3
4
5
2
```
 样例输出 
```
3
```
### 详解
很简单的二分，二分要注意的问题看这里https://github.com/yvette-moon/Basic-algorithm-learning/blob/main/%E4%BA%8C%E5%88%86%E6%B3%95%E4%B8%80%E5%AE%9A%E4%B8%8D%E8%A6%81%E5%86%8D%E9%94%99%E5%95%A6.md

代码
```
#include <iostream>
#include <vector>
using namespace std;

int binarySearch(const vector<int>& apples,int target) {
    int left=0;
    int right=apples.size() - 1;
    int count=0;
    while (left<=right) {
        count++;
        int mid=left+(right-left)/2;
      if (apples[mid]==target) {
            return count;
        }
      else if (apples[mid]<target) {
            left=mid+1;
        } else {
            right=mid-1;
        }
    }
    
    return -1; // 表示没找到
}

int main() {
    int n;
    cin>>n;
    vector<int> apples(n);
    
    for (int i=0;i<n;i++) {
        cin>>apples[i];
    }
    
    int target;
    cin>>target;    
    int result=binarySearch(apples,target);
    if (result!=-1) {
        cout <<result<< endl;
    } else {
        cout<<"I can't find it."<<endl;
    }
    
    return 0;
}
```
## 问题 D: 排列的字典序问题    
### 题目描述
**n个元素{1,2,……, n }有n!个不同的排列。将这n!个排列按字典序排列，并编号为0，1，…，n!-1。每个排列的编号为其字典序值。例如，当n=3时，6 个不同排列的字典序值如下： 
给定n以及n个元素{1,2,……, n }的一个排列，计算出这个排列的字典序值，以及按字典序排列的下一个排列。**      
 输入
 输入数据的第1行是元素个数n（n≤20）。接下来的1行是n个元素 {1,2,……, n }的一个排列
 输出
输出数据的第1行是字典序值，第2行是按字典序排列的下一个排列。    
**输入输出样例**
               
样例输入 
```
8
2 6 4 5 8 1 7 3
```
 样例输出 
```
8227
2 6 4 5 8 3 1 7
```
### 详解
我的想法是啊，定义一个数组a存储数字，dps全排列
