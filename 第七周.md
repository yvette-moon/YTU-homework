# 问题 A: C 语言习题 字符串排序      
   ## 题目描述
**输入 n 个字符串，将它们按字母由小到大的顺序排列并输出。编写三个函数实现，input 用于输入 n个字符串，sortstr 用于排序 n个字符串，output 用于输出 n个字符串**

输入:
第一行n第二行到第n+1行，每行一个字符串        
输出:
 排序后的字符串  
 
输入输出样例
样例输入:
```
 3
YTU
ACM
COM
```
 样例输出 :
```           
 ACM
COM
YTU
```            
提示
主函数已给定如下，提交时不需要包含下述主函数C:
```
int main()
{
    char str[10][10];
    int n;
    scanf("%d", &n);
    input(str, n);
    sortstr(str, n);
    output(str, n);
    return 0;
}
```
```
C++:
int main()
{
    string str[10];
    int n;
    cin >> n;
    input(str, n);
    sortstr(str, n);
    output(str, n);
    return 0;
}
```
### 详解

编写三个函数 input output sortstr

学习怎么处理字符串

给出的c++代码中用了字符串数组，我们利用for循环直接输入输出就好，sortstr则直接而用sort函数。

示例代码：
c++
```
#include <iostream>
#include <string>
#include <algorithm>
using namespace std;

void input(string str[10], int n) {
    for (int i=0; i<n;i++) {
        cin >> str[i];
    }
}

void sortstr(string str[10], int n) {
    sort(str, str + n);
}

void output(string str[10], int n) {
    for (int i = 0; i < n; i++) {
        cout << str[i] << endl;
    }
}
```

   —————— The end——————
## 问题 B: 交换瓶子
### 题目描述
有N个瓶子，编号 1, 2... N，放在架子上。比如有 5 个瓶子：2 1 3 5 4要求每次拿起 2个瓶子，交换它们的位置。经过若干次后，使得瓶子的序号为：$1 2 3 4 5$对于这么简单的情况，显然，至少需要交换 $2$ 次就可以复位。如果瓶子更多呢？你可以通过编程来解决。

输入

第一行有一个正整数N (N< 10000), 表示瓶子的数目第二行有N个正整数，用空格分开，表示瓶子目前的排列情况。        

输出
        
输出数据为一行一个正整数，表示至少交换多少次，才能完成排序。    

输入输出样例 
输入
```
5
3 1 2 5 4
```
输出
```
3
```
### 详解
**贪心**
遇到不对的就把该位置的数和应该的数交换，比如说例子中，3的位置不对，应该的数字是1，把1和3交换，交换后得到1 3 2 5 4
难处理的地方在于，怎么找到应该的数并交换，一种方法是两个for循环，第一层找不适合的数，第二层找应该的数，找到后交换，计数器加一
```
#include<bits/stdc++.h>
using namespace std;
int main(){
    int n;
    int bottle[10005];
    cin>>n;
    for(int i=1;i<=n;i++){
        cin>>bottle[i];
    }
    int ans=0;
    for(int i=1;i<=n;i++){
        if(bottle[i]!=i){
            for(int j=i;j<=n;j++){
                if(bottle[j]==i){
                    swap(bottle[i],bottle[j]);
                    ans++;
                    break;
                }
            }
        }
       
    }
    cout<<ans;
    return 0;
}
```
OJ上可以通过，但是该方法时间复杂度高，要是n>10000就会超时
我们可以利用一个数组储存数字位置来减少时间复杂度
```
#include<bits/stdc++.h>
using namespace std;
int main(){
    int n;
    int bottle[10005];
    cin>>n;
    int pos[10005];
    for(int i=1;i<=n;i++){
        cin>>bottle[i];
        pos[bottle[i]]=i;
    }
    int ans=0;
    for(int i=1;i<=n;i++){
        if(bottle[i]!=i){
            swap(bottle[i],bottle[pos[i]]);
            pos[bottle[pos[i]]]=pos[i];
            pos[i]=i;
            ans++;
        }
       
    }
    cout<<ans;
    return 0;
}
```
OJ同样可通过，当然肯定还有别的好方法。


   —————— The end——————
   
## 问题 C: 二分查找      
### 题目描述
**小 C 同学有 $n$ 个苹果，每个苹果的甜度都不相同，他现在想要吃一个甜度为 $a$ 的苹果，可他又不想一个个去找，聪明的你能帮他在最少次数 (相对次数最少) 内找出甜度为 $a$ 的苹果吗?**      
 输入
 第一行输入苹果的个数 $n$ ($0 \lt n \lt 300000$).下面 $n$ 行从小到大输入苹果的甜度。(保证没有重复）第 $n+2$ 行，输入需要找的苹果的甜度.        
输出
若找到，输出你寻找的次数。否则，输出 I can't find it.        
**输入输出样例**
               
样例输入 
```
5
1
2
3
4
5
2
```
 样例输出 
```
3
```
### 详解
很简单的二分，二分要注意的问题看这里https://github.com/yvette-moon/Basic-algorithm-learning/blob/main/%E4%BA%8C%E5%88%86%E6%B3%95%E4%B8%80%E5%AE%9A%E4%B8%8D%E8%A6%81%E5%86%8D%E9%94%99%E5%95%A6.md

代码
```
#include <iostream>
#include <vector>
using namespace std;

int binarySearch(const vector<int>& apples,int target) {
    int left=0;
    int right=apples.size() - 1;
    int count=0;
    while (left<=right) {
        count++;
        int mid=left+(right-left)/2;
      if (apples[mid]==target) {
            return count;
        }
      else if (apples[mid]<target) {
            left=mid+1;
        } else {
            right=mid-1;
        }
    }
    
    return -1; // 表示没找到
}

int main() {
    int n;
    cin>>n;
    vector<int> apples(n);
    
    for (int i=0;i<n;i++) {
        cin>>apples[i];
    }
    
    int target;
    cin>>target;    
    int result=binarySearch(apples,target);
    if (result!=-1) {
        cout <<result<< endl;
    } else {
        cout<<"I can't find it."<<endl;
    }
    
    return 0;
}
```
## 问题 D: 排列的字典序问题    
### 题目描述
**n个元素{1,2,……, n }有n!个不同的排列。将这n!个排列按字典序排列，并编号为0，1，…，n!-1。每个排列的编号为其字典序值。例如，当n=3时，6 个不同排列的字典序值如下： 
给定n以及n个元素{1,2,……, n }的一个排列，计算出这个排列的字典序值，以及按字典序排列的下一个排列。**      
 输入
 输入数据的第1行是元素个数n（n≤20）。接下来的1行是n个元素 {1,2,……, n }的一个排列
 输出
输出数据的第1行是字典序值，第2行是按字典序排列的下一个排列。    
**输入输出样例**
               
样例输入 
```
8
2 6 4 5 8 1 7 3
```
 样例输出 
```
8227
2 6 4 5 8 3 1 7
```
### 详解
我的想法是啊，定义一个数组a存储数字，dfs全排列,因为dfs排列的话，初始数组是升序的话，排出来的也是升序，只要有计数器，等排出来的数组和原数组一致的时候，输出计数器，再往下排列一个输出该排列，这是一开始的代码：
```
#include<bits/stdc++.h>
using namespace std;
int a[25];
int vis[25]={0};
int b[25];
int att[25];
int ans=-1;
int n;
int cnt=-100;
void dfs(int step){
     if(step==n+1){
        ans++;  
        bool k=true; //检查是否符合原数组 
        for(int i=1;i<=n;i++){
            if(b[i]!=att[i])
            {k=false;
            break;}
        }//如果符合，输出ans并记录，等到下一个的时候输出数组
        if(k){
            cout<<ans<<endl;; 
            cnt=ans;
        }
        if(ans==cnt+1){
            for(int i=1;i<=n;i++){
                cout<<b[i]<<" ";
            } 
            return ;
        }
        return ;
     }
     for(int i=1;i<=n;i++){
        if(vis[i]==0){
            b[step]=a[i];
            vis[i]=1;
            dfs(step+1);
            vis[i]=0;
        }
     }
     return ;
}
int main(){
    cin>>n;
    for(int i=1;i<=n;i++){
        cin>>a[i];
        att[i]=a[i];
    }
    sort(a+1,a+n+1);
    dfs(1);
    return 0;
}
```
但是啊原题目n最大为二十，明显时间超限，所以这个代码在oj没通过（哭；
可是我学艺不精，不会dfs剪枝也不会其他方法（好像dfs剪枝也不能通过），所以我ai了，以下是ds给我的代码：
```
#include<bits/stdc++.h>
using namespace std;

int a[25], n;
vector<int> original;

// 计算阶乘用于序号计算
long long factorial(int x) {
    long long res = 1;
    for(int i=2; i<=x; i++) res *= i;
    return res;
}

// 计算当前排列的字典序值
long long calculateRank() {
    vector<int> nums = original;
    vector<int> sorted = nums;
    sort(sorted.begin(), sorted.end());
    
    long long rank = 0;
    for(int i=0; i<n; i++) {
        auto it = find(sorted.begin(), sorted.end(), nums[i]);
        int pos = distance(sorted.begin(), it);
        rank += pos * factorial(n - i - 1);
        sorted.erase(it);
    }
    return rank;
}

// 计算下一个排列
void nextPermutation() {
    vector<int> nums = original;
    int i = n-2;
    while(i >= 0 && nums[i] >= nums[i+1]) i--;
    
    if(i == -1) {
        // 已经是最后一个排列
        for(int j=0; j<n; j++) cout << original[j] << " ";
        return;
    }
    
    int j = n-1;
    while(nums[j] <= nums[i]) j--;
    swap(nums[i], nums[j]);
    reverse(nums.begin()+i+1, nums.end());
    
    for(int num : nums) cout << num << " ";
}

int main() {
    cin >> n;
    original.resize(n);
    for(int i=0; i<n; i++) {
        cin >> original[i];
        a[i] = original[i];
    }
    
    cout << calculateRank() << endl;
    nextPermutation();
    
    return 0;
}
```
非常巧妙（拍手

DFS的时间复杂度通常是O(n!)，而上面代码中查找下一个排列的函数 nextPermutation()只有O(n)，这个函数也是标准库的next_permutation算法思想，下面具体解释代码

**首先，对于字典序，ai给的代码选择直接计算**
```
long long calculateRank() {
    vector<int> nums = original;
    vector<int> sorted = nums;
    sort(sorted.begin(), sorted.end());
    
    long long rank = 0;
    for(int i=0; i<n; i++) {
        auto it = find(sorted.begin(), sorted.end(), nums[i]);
        int pos = distance(sorted.begin(), it);
        rank += pos * factorial(n - i - 1);
        sorted.erase(it);
    }
    return rank;
}
```
**这是字典序计算原理：**

以排列[2,1,3]为例：

1. 排序后参考序列：[1,2,3]
2. 计算过程：
   - 第一位2：
     - 比2小的有1（个数=1）
     - 贡献：1×2! = 2
   - 第二位1：
     - 可用数字[1,3]中比1小的有0个
     - 贡献：0×1! = 0
   - 第三位3：
     - 固定位置，贡献0
   - 总字典序值：2 + 0 + 0 = 2
- 总和：2 + 0 + 0 = 2
- 
  **以上代码，把原数组放到sort数组后把该数组sort，原数组给num，然后在sort中找每一个原数组元素的位置为
it，通过计算该元素z在sort数组中的位置到sort的起始位置的距离，计算有几个数小于该元素这个数量等于pos，然后利用以上原理计算，factorial用于计算阶乘。**

**然后是extPermutation()部分：**
```
void nextPermutation() {
    vector<int> nums = original;
    int i = n-2;
    while(i >= 0 && nums[i] >= nums[i+1]) i--;
    
    if(i == -1) {
        // 已经是最后一个排列
        for(int j=0; j<n; j++) cout << original[j] << " ";
        return;
    }
    
    int j = n-1;
    while(nums[j] <= nums[i]) j--;
    swap(nums[i], nums[j]);
    reverse(nums.begin()+i+1, nums.end());
    
    for(int num : nums) cout << num << " ";
}
```
1.从右找，找到第一个不是升序的数，以2 6 4 5 8 1 7 3为例，找到为 1 ，
2.再找第一个（从右找）比 1 大的数，该数为 3 ，
3.交换位置，得到，2 6 4 5 8 3 7 1，
4. 反转i+1到末尾的部分 得到，2 6 4 5 8 3 1 7，

**为什么这样工作？**
- 字典序要求我们找到尽可能靠右的修改点
- 交换后，i+1之后的部分是降序的，反转后变成升序，确保这是最小的增大
- 当i=-1时，说明整个排列是降序的，已经是最大排列

   —————— The end——————
