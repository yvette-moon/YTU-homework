# 题目描述
      
 圣诞节来临了，在城市 $A$ 中，圣诞老人准备分发糖果。现在有多箱不同的糖果，每箱糖果有自己的价值和重量，每箱糖果都可以拆分成任意散装组合带走。圣诞老人的驯鹿最多只能承受一定重量的糖果，请问圣诞老人最多能带走多大价值的糖果。      
 输入
 
输入的第一行由两个部分组成，分别为糖果箱数正整数 $n$ $(1 \le n \le 100)$, 驯鹿能承受的最大重量正整数 $w$ $(0 \lt w \lt 10000)$, 两个数用空格隔开；其余 $n$ 行每行对应一箱糖果，由两部分正整数 $t$ 和 $v$ 组成，分别为一箱糖果的价值和重量，中间用空格隔开。        
输出
        
输出圣诞老人能带走的糖果的最大总价值，保留 $1$ 位小数。        
输入输出样例
 样例输入 #1
4 15
100 4 
412 8 
266 7
591 2
 样例输出 #1
1193.0
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,w;
struct candy{
    int v,we;
    double k;
};
bool cmp(candy x,candy y){
    return x.k>y.k;
}
int main(){
    cin>>n>>w;
    candy can[n];
    for(int i=0;i<n;i++){
        cin>>can[i].v>>can[i].we;
        can[i].k=(double)can[i].v/can[i].we;
    }
    sort(can,can+n,cmp);
   double  max_va=0.0;
    for(int i=0;i<n;i++){
        if(w>can[i].we){
            max_va+=can[i].v;
            w-=can[i].we;
        }
        else {
            max_va+=can[i].k*w;
            break;
        }
    }
    cout<<fixed<<setprecision(1)<<max_va<<endl;
    return 0;
}
```
# 问题 B: 电池的寿命            
# 题目描述
小S新买了一个掌上游戏机，这个游戏机由两节5号电池供电。为了保证能够长时间玩游戏，他买了很多 $5$ 号电池，这些电池的生产商不同，质量也有差异，因而使用寿命也有所不同，有的能使用 $5$ 个小时，有的可能就只能使用 $3$ 个小时。显然如果他只有两个电池一个能用 $5$ 小时一个能用 $3$ 小时，那么他只能玩 $3$ 个小时的游戏，有一个电池剩下的电量无法使用，但是如果他有更多的电池，就可以更加充分地利用它们，比如他有三个电池分别能用 $3$、$3$、$5$ 小时，他可以先使用两节能用 $3$ 个小时的电池，使用半个小时后再把其中一个换成能使用 $5$ 个小时的电池，两个半小时后再把剩下的一节电池换成刚才换下的电池（那个电池还能用 $2.5$ 个小时），这样总共就可以使用 $5.5$ 个小时，没有一点浪费。 现在已知电池的数量和电池能够使用的时间，请你找一种方案使得使用时间尽可能的长。       
  输入
        
 输入包含多组数据。每组数据包括两行，第一行是一个整数 $N$ ($2 \le N \le 1000$)，表示电池的数目，接下来一行是 $N$ 个正整数表示电池能使用的时间        
 输出
        
 对每组数据输出一行，表示电池能使用的时间，保留到小数点后 $1$ 位。        
       
                
 样例输入 #1
2
3 5
3
3 3 5
                
样例输出 #1
 3.0
5.5
 提示
        
 电池的电量不止仅仅是3和5！！还有可能是其他的数（小于1000）
 ```cpp
#include<bits/stdc++.h>
using namespace std;

int main(){
   int n;
   while(cin>>n){
    double sum=0,max=-1;
    vector<int> b(n);
    for(int i=0;i<n;i++){
        cin>>b[i];
        sum+=b[i];
        if(max<b[i]) max=b[i];
    }
    if((sum-max)<max)
    {
        printf("%.1f\n",(sum-max)*1.0);
    }
    else {
        printf("%.1f\n",(sum-max-max)*1.0/2+max);
    }
}
   return 0;
}

```
# 题目描述
      
中国古代一个有名的故事 ” 田忌赛马” 。 田忌和齐王赛马， 他们各有 $n$ 匹马，依次派出一匹马进行比赛， 每一轮获胜的一方将从输的一方获得 $200$ 银币， 平局则不用出钱。其中每匹马只能出场一次，每匹马有一个速度值，在比赛中速度快的马一定会获胜。田忌知道所有马的速度值，且田忌可以安排每轮双方出场的马。问田忌如何安排马的出场顺序，使得最后获得的钱最多？      
输入
        
输入包含若干组数组， 每个数据的第 $1$ 行是一个整数 $n$ ($n \le 1000$)，表示齐王和田忌各有 $n$ 匹马， 后面的两行每行有 $n$ 个数，分别表示田忌 $n$ 匹马和齐王 $n$ 匹马的速度值。测试数据以 0 结束。        
 输出
        
输出有若干行，每行输出对应一组输入。输出是一个整数，表示田忌最多获得的钱数 （损失钱则用负数表示）。        
 样例输入 #1
 3
92 83 71
95 87 74
2
20 20
20 20
2
20 19
22 18
0
样例输出 #1
 200
0
0
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    //ios::sync_with_stdio(false); // 关闭同步，提升输入输出速度
   // cin.tie(nullptr);            // 解绑cin和cout，减少IO等待
    
    int n;
    while (cin >> n && n != 0) {
        vector<int> tian(n), qi(n);
        for (int i = 0; i < n; ++i) {
            cin >> tian[i];
        }
        for (int i = 0; i < n; ++i) {
            cin >> qi[i];
        }
        sort(tian.begin(), tian.end());
        sort(qi.begin(), qi.end());
        
        int t_low = 0, t_high = n - 1;
        int q_low = 0, q_high = n - 1;
        int ans = 0;
        
        while (t_low <= t_high) {
            if (tian[t_high] > qi[q_high]) {
                ans += 200;
                t_high--;
                q_high--;
            } else if (tian[t_high] < qi[q_high]) {
                ans -= 200;
                t_low++;
                q_high--;
            } else {
                if (tian[t_low] > qi[q_low]) {
                    ans += 200;
                    t_low++;
                    q_low++;
                } else {
                    if (tian[t_low] < qi[q_high]) {
                        ans -= 200;
                    }
                    t_low++;
                    q_high--;
                }
            }
        }
        cout << ans << '\n'; // 使用'\n'代替endl，减少刷新操作
    }
    return 0;
}
```
# 题目描述
      
        小明准备去钓鱼，他准备在一个有 $n$ 个湖的地方钓 $h$ 小时，小明只能按顺序从第 1 个湖 开始，依次在各个湖钓鱼，但是在每个湖的钓鱼时间是由小明自己决定的。从第 $i$ 个湖走到第 $i+1$ 个湖的时间是 $t_i$ 个 $5$ 分钟。例如 $t_3 = 4,$ 表明从第 $3$ 个湖走到第 $4$ 个湖需要 $20$ 分钟。对于每个湖 $i$ ，在初始的 $5$ 分钟，小明可以钓到 $f_i$ 条鱼，之后每过 $5$ 分钟，可钓到的鱼会 减少 $d_i$, 直到减少为 $0$ 。如果当前没有在湖中钓鱼，那么可以钓到的鱼的数量是不变的。假设 当前只有小明在钓鱼，请问如果规划钓鱼的安排，使得能钓上的鱼最多? 小明在每个湖的钓鱼时间必须是 $5$ 分钟的倍数。      
 输入
        
          输入数据包括多组数据。每组数据的第一行包含一个数 $n$ ($2 \le n \le 25$), 表示湖的个数。第二行包含一个数 $h$ ($1 \le h \le 16$), 表示小明钓鱼的小时数。第三行包含 $n$ 个数，给出 $f_i$ $(f_i \ge 0$)。第四行包含 $n$ 个数，给出 $d_i$ $(d_i \ge 0$)。接下来一行包含 $n - 1$ 个数，给出 $t_i (0 \le t_i \le 192$)。输入以 $n = 0$ 结束。        
 输出
        
          对于每一组测试数据，第一行输出在每个湖中钓鱼的时间，用逗号隔开：第二行输出期 望钓到的最多的鱼的数量。 如果有多种可能的方案，则尽可以在 $1$ 号湖多钓鱼，即使 $1$ 号湖中已经没有鱼了; 如果还有多种方案，则尽可能在 $2$ 号湖中多钓鱼，以此类推。两组数据之间用空行隔开。        
  样例输入 #1
 2
1
10 1
2 5
2
4
4
10 15 20 17
0 3 4 3
1 2 3
4
4
10 15 50 30
0 3 4 3
1 2 3
0

45, 5
Number of fish expected: 31

240, 0, 0, 0
Number of fish expected: 480

115, 10, 50, 35
Number of fish expected: 724
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    int n;
    bool first_case = true;
    while (cin >> n && n != 0) {
        if (!first_case) {
            cout << endl;
        }
        first_case = false;

        int h;
        cin >> h;
        int total_time = h * 12;

        vector<int> f(n);
        for (int i = 0; i < n; ++i) {
            cin >> f[i];
        }

        vector<int> d(n);
        for (int i = 0; i < n; ++i) {
            cin >> d[i];
        }

        vector<int> t;
        if (n > 1) {
            t.resize(n - 1);
            for (int i = 0; i < n - 1; ++i) {
                cin >> t[i];
            }
        }

        int max_fish = -1;
        vector<int> best_counts(n, 0);
        int best_k = 0;

        for (int k = 1; k <= n; ++k) {
            int walk_time = 0;
            for (int i = 0; i < k - 1; ++i) {
                walk_time += t[i];
            }

            int fish_time = total_time - walk_time;
            if (fish_time <= 0) {
                continue;
            }

            vector<int> current_f;
            for (int i = 0; i < k; ++i) {
                current_f.push_back(f[i]);
            }

            vector<int> count(k, 0);
            int current_total = 0;

            for (int step = 0; step < fish_time; ++step) {
                int max_val = -1;
                int index = 0;
                for (int i = 0; i < k; ++i) {
                    if (current_f[i] > max_val) {
                        max_val = current_f[i];
                        index = i;
                    }
                }
                count[index]++;
                current_total += max_val;
                current_f[index] = max(current_f[index] - d[index], 0);
            }

            vector<int> full_count(n, 0);
            for (int i = 0; i < k; ++i) {
                full_count[i] = count[i];
            }

            if (current_total > max_fish) {
                max_fish = current_total;
                best_counts = full_count;
                best_k = k;
            } else if (current_total == max_fish) {
                if (k < best_k) {
                    best_counts = full_count;
                    best_k = k;
                } else if (k == best_k) {
                    for (int i = 0; i < k; ++i) {
                        if (full_count[i] > best_counts[i]) {
                            best_counts = full_count;
                            break;
                        } else if (full_count[i] < best_counts[i]) {
                            break;
                        }
                    }
                }
            }
        }

        for (int i = 0; i < n; ++i) {
            if (i > 0) {
                cout << ", ";
            }
            cout << best_counts[i] * 5;
        }
        cout << endl;
        cout << "Number of fish expected: " << max_fish << endl;
    }
    return 0;
}
```
# 题目描述
      
 农场有 $N$ 头牛，每头牛会在一个特定的时间区间 $[A, B]$ (包含 $A$ 和 $B$ ) 在畜栏里挤奶,且一个畜栏里同时只能有一头牛在挤奶。现在农场主希望知道最少几个畜栏能满足上述要求， 并要求给出每头牛被安排的方案。对于多种可行方案，输出一种即可。      
输入
        
输入的第一行包含一个整数 $N$ ($1 \le N \le 50000$), 表示有 $N$ 牛头; 接下来 $N$ 行每行包含两 个数，分别表示这头牛的挤奶时间 $\left[A_i, B_i \right]$ ($1 \le A \le B \le 1000000$) 。        
 输出
        
输出的第一行包含一个整数，表示最少需要的畜栏数：接下来 $N$ 行，第 $i + 1$ 行描述第 $i$ 头牛被分配的畜栏编号（从 $1$ 开始）。        
 样例输入 #1

              5
1 10
2 4
3 6
5 8
4 7
  样例输出 #1
 4
1
2
3
2
4
提示
此题需要编写特判，如果没有特判，请按照只排序左区间的策略进行。
```cpp
#include <iostream>
#include <queue>
#include <algorithm>
#include <vector> 
using namespace std;
struct cows{
    int left,right;
    int idx;
};
bool cmp(cows x,cows y){
    if(x.left!=y.left)
    return x.left<y.left;
    else
    return x.right<y.right;
}
int main() {
   int n;
   cin>>n;
  vector<cows> cow(n);
   for(int i=0;i<n;i++){
    cin>>cow[i].left>>cow[i].right;
    cow[i].idx=i;
   }
   sort(cow.begin(),cow.end(),cmp);
   priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>> pq;
   vector<int> res(n);
   for(int i=0;i<n;i++){
     if(!pq.empty()&&pq.top().first<cow[i].left){
        int a=pq.top().first;
        int b=pq.top().second;
        pq.pop();
        res[cow[i].idx]=b;
        pq.emplace(cow[i].right,b);
     }
     else {
        int newid=pq.size()+1;
        res[cow[i].idx]=newid;
        pq.emplace(cow[i].right,newid);
     }
   }
   cout<<pq.size()<<endl;
   for(int i=0;i<n;i++){
    cout<<res[i]<<endl;
   }
    return 0;
}
```
oj不通过，输出数据是对的，不知道为什么不通过。
