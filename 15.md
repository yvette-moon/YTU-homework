## 题目描述
小虎是游戏中的一个国王，在他管理的国家中发行了很多不同面额的纸币，用这些纸币进行任意的组合可以在游戏中购买各种装备来提升自己。有一天，他突然很想知道这些纸币的组合不能表示的最小面额是多少，请聪明的你来帮助小虎来解决这个财政问题吧。

输入

输入包含多个测试用例，每组测试用例的第一行输入一个整数 $N$ $(N \le 100)$ 表示流通的纸币面额数量，第二行是 $N$ 个纸币的具体表示面额，取值 $[1, 100]$。

输出

对于每组测试用例，输出一个整数，表示已经发行的所有纸币都不能表示的最小面额（已经发行的每个纸币面额最多只能使用一次,但面值可能有重复）。

首先的想法是dfs组合出每种情况再找最小的不能表示的，但是复杂度太高了吧，
给出的题要求用动态规划，具体的实现方法就是
1.设置一个一维bool dp数组，dp[i]表示是否可以组成i金额。
2.初始化dp[0]=true
3.一个用一次，从后向前选择
4.状态转移：如果dp[j]==true,则可以叠加目标coin，叠加后的金额再设为true
最后找到最小的flase输出就好。

注意：考虑到都可以组成的情况，所以最后遍历的时候搜索到sum+1

```cpp
#include <bits/stdc++.h>
using namespace std;

int main() {
    int n;
    while (cin >> n && n != 0) {
        vector<int> coins(n);
        int sum = 0;
        for (int i = 0; i < n; i++) {
            cin >> coins[i];
            sum += coins[i];
        }

        vector<bool> dp(sum + 1, false);
        dp[0] = true;

        for (int i=0;i<n;i++) {
            int coin=coins[i];
            for (int j = sum - coin; j >= 0; j--) {
                if (dp[j])
                    dp[j + coin] = true;
            }
        }

        for (int i = 1; i <= sum+1; i++) {
            if (!dp[i]) {
                cout << i << endl;
                break;
            }
        }
    }
    return 0;
}
```
## 题目描述
有一个由 $[1, 9]$ 组成的数字串，问如果将 $m$ 个加号插入到这个数字串中，在各种可能形成的表达式中，值最小的那个表达式的值是多少。例如，在 $1234$ 中摆放 $1$ 个加号，最好的摆法就是 $12+34$，和为 $36$。

输入

有不超过 $15$ 组数据。每组数据两行。第一行是整数 $m$，表示有 $m$ 个加号要放 $(0 \le m \le 17)$。第二行是若干个数字。数字总数 $n$ 不超过 $18$ 且 $m \le n-1$。

输出

对每组数据，输出最小加法表达式的值。

1.dp[i][j]表示前i个数字内加入j个加号之后得到的最小值。
2.初始化：dp[i][0]=前i个数字，最大设置为1e9。
3.状态转移：本身，或者前j~i-1个加j-1个加号再加剩下的数字的情况，所以要三层的for循环。
比如说 

2

123456

  |0     | 1                    | 2
  
0 |1e9   | 1e9                  |1e9

1 |1     | 1e9                  |

2 |12    | 3(1+2)               |

3 |123   | (1+23)/(12+3)/1e9    |

4 |1234

5 |12345

6 |123456

```cpp
#include <bits/stdc++.h>
using namespace std;
string a;
typedef long long ll;
ll sh(ll s,ll o){
    ll sum=0;
    for(ll k=s;k<=o;k++){
          sum=sum*10+(a[k]-'0');
    }
    return sum;
}
int main() {
    ll m;
    while(cin>>m){
    cin>>a;
    ll n=a.size();
    vector<vector<ll>> dp(n+1,vector<ll>(m+1,1e9));
    for(ll i=1;i<=n;i++){
        dp[i][0]=sh(0,i-1);
    }
    for(ll i=1;i<=n;i++){
        for(ll j=1;j<=m&&j<i;j++){
            for(ll k=j;k<i;k++)
            dp[i][j]=min(dp[i][j],dp[k][j-1]+sh(k,i-1));
        }
    }
    cout<<dp[n][m]<<endl;
}
    return 0;
}
```


