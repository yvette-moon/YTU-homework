# 问题 A: 城堡问题
**题目描述**
如图为一个地堡的地形图。编写一个程序，计算城堡一共有多少个房间，最大的房间有多大。城堡被分割成 $m \times n$ $(n \le 50, n \le 50)$ 个方块，每个方块可以有 $0 \sim 4$ 面墙。# 代表墙壁，| 和 - 都表示没有墙壁。不被墙分割的方块连在一起组成一个房间。城堡外围一圈都是墙。
  
 **输入**
        
  第一行是两个整数 $R$ 和 $C$，分别是南北向、东西向的方块数。
  接下来是一个 $R$ 行 $C$ 列的整数矩阵，每个整数 $p$ 描述一个方块（$0 \le p \le 50$）

如果用 $1$ 对应西墙，$2$ 对应北墙，$4$ 对应东墙，$8$ 对应南墙，则用来描述一个方块的整数，其值就是该方块周围每个墙所对应的数字之和。
例如，某方块有南墙和北墙，则描述它的整数就是 $2 + 8 = 10$。某方块四面都有墙，则描述它的整数就是 $1 + 2 + 4 + 8 = 15$。输入的数据保证城堡至少有两个房间。
  **输出**
城堡的房间数、城堡中最大房间所包括的方块数。

## 问题分析
看似还是一个bfs连通性问题，如果有图的话，无非是#围成的最大区域，但是不给图，给的数字，那我们看看能不能变成图
似乎有点难办
那我们想想核心的bfs怎么写
* 预备工作：定义方向数组dx dy，队列 储存当前坐标和标记，bool visit数组标记是否访问过，
* 初始化：把初始坐标载入，标记访问过
* 循环，当表不为空时，储存第一个，删除队列第一个，检查此时是否到达终点
* 在遍历这个节点的四个方向，检查边界以及连通性以及是否访问过，都符合，进队列
  
这个是求连续地块的思路，对应bfs那一篇的例题
要求最大的连续地块步骤会有所改动
* 准备工作，四个方向，visit标记，maxsize设置一个很小的数，队列
* main函数中，采用for循环遍历表中节点，如果是没被访问过的，进入比方说，返回地块大小值，与maxsize比较取大值
* bfs中int size=0，创建队列，初始化
* while（！q.empty)
* 储存现节点，出q队列，遍历四个方向，符合条件进队列，size++，标记为访问过

不过我们到底要怎么才能检验连通性？

那我们对于每一个点，无非就是判断能不能加入队列，只要有墙不就不能加了吗
那例如当我们访问3.4的上一个节点2.4时，判断3.4上面是否有墙，3.4如果对应的是7，7=1+2+4，上面有墙，pass
接下来我们来给出所以1 2 4 8的组合数

* 左方有墙的数：1，3，5，9，7，11，13，15
* 上方：2，3，6，10，7，11，14，15
* 右方：4，5，6，12，7，13，14，15
* 下方：8，9，10，12，14，13，11，15
```cpp
#include<bits/stdc++.h>
using namespace std;
int dx[]={1,-1,0,0};
int dy[]={0,0,-1,1};
int n,m;
 vector<vector<bool>> visit(50,vector<bool>(50,false));
int maxsize=-1e9;
vector<vector<int>> wall;
struct node{
    int x,y;
};
bool isvalid(int a,int ax,int ay){
    if(a==1)//上
    {
        if(wall[ax][ay]==2||wall[ax][ay]==3||wall[ax][ay]==6||wall[ax][ay]==10||wall[ax][ay]==7||wall[ax][ay]==11||wall[ax][ay]==14||wall[ax][ay]==15)
        return false;
        else return true;
    }
    else if(a==0)//xia
    {
        if(wall[ax][ay]==8||wall[ax][ay]==9||wall[ax][ay]==10||wall[ax][ay]==12||wall[ax][ay]==14||wall[ax][ay]==13||wall[ax][ay]==11||wall[ax][ay]==15)
        return false;
        else return true;
    }
   else  if(a==2)//zuo
    {
        if(wall[ax][ay]==1||wall[ax][ay]==3||wall[ax][ay]==5||wall[ax][ay]==9||wall[ax][ay]==7||wall[ax][ay]==11||wall[ax][ay]==13||wall[ax][ay]==15)
        return false;
        else return true;
    }
    else if(a==3)
    {
        if(wall[ax][ay]==4||wall[ax][ay]==5||wall[ax][ay]==6||wall[ax][ay]==12||wall[ax][ay]==7||wall[ax][ay]==13||wall[ax][ay]==14||wall[ax][ay]==15)
        return false;
        else return true;
    }
    return false;
}
int bfs(int startx,int starty){
     int size=0;
     queue<node> q;
     q.push({startx,starty});
     visit[startx][starty]=true;
     size++;
     while(!q.empty()){
           node current=q.front();
           q.pop();
           for(int i=0;i<4;i++){
            int nx=current.x+dx[i];
            int ny=current.y+dy[i];
            if(nx>=0&&nx<n&&ny>=0&&ny<m&&!visit[nx][ny]&&isvalid(i,current.x,current.y)){
                q.push({nx,ny});
                visit[nx][ny]=true;
                size++;
            }
           }
     }
     return size;
}
int main(){
    cin>>n>>m;
    int count=0;
    wall.resize(n,vector<int>(m));
    for(int i=0;i<n;i++){
        for(int j=0;j<m;j++){
            cin>>wall[i][j];
        }
    }
    for(int i=0;i<n;i++){
        for(int j=0;j<m;j++){
            if(visit[i][j]==false)
           {
                count++;
             maxsize=max(maxsize,bfs(i,j));
            }
        }
    }
    cout<<count<<endl<<maxsize<<endl;
    return 0;
}
```
基本是按照上面的思路写的，但是类bfs可能是实在不熟悉所以写的很慢还有错误，甚至访问后visit没标记。。。
# 问题 B: ROADS
**题目描述**
有 $N$ 个城市，编号为 $1$ ~ $N$。城市间有 $N$ 条单向道路，每条道路连接两个城市，有长度和过路费两个属性。Bob 只有 $K$ 块钱，他想从城市 $1$ 走到城市 $N$。问最短需要走多长的路。如果到不了 $N$，输出 $-1$。其中，$2 <+ N<=100$；$0 <= K <= 10000$；$1 \le R \le 10000$；每条路的长度为 $L$，$1 \le L \le 100$；每条路的过路费为 $T$，$0 \le T \le 100$。

输入
        
第一行是 $K$，第二行是 $N$，第三行是 $R$。接下来有 $R$ 行，每行有 $4$ 个整数 $s, e, L, T$，表示从城市 $s$ 到城市 $e$ 有一条单向路（可以沿该路从 $s$ 走到 $e$，但不能沿该路从 $e$ 走到 $s$），其长度是 $L$，过路费是 $T$。  

 输出
        
 只有一行，就是问题答案。        
 ## 问题分析
 我自己分析不出来，找的ai代码分析的。

 使用动态规划寻找最优解，但是给出数据的形式就注定了这不是一个传统的动态规划。

 我们先确定用一个结构体road来储存 **s**起点、**e**结束点、**L**路径长度、**T**价钱。
 
然后再确定dp：
我们需要考虑的是当前所在的城市和过路费，可以设置dp[i][j]为到第i个城市，已经花费j元走的最短距离。

* 初始化：起点为1，路费为0，所以dp[1][0]=0;
* 状态转移：对于每个过路费j，搜寻其可能的道路。如果当前所在城市为s已经花费j元，那么走这条路的话，j+T<=k,新路径dp[e][j+T]=min(dp[s][j]+L,dp[e][j+T])。

**但是有个问题：这个是从第一个城市到最后一个城市，遇到5->4这样折返的就没法处理了
```cpp
#include<bits/stdc++.h>
using namespace std;
struct road{
    int s,e,L,T;
}roads[10005];
int main(){
    int k,n,r;
    cin>>k>>n>>r;
    for(int i=1;i<=r;i++){
        cin>>roads[i].s>>roads[i].e>>roads[i].L>>roads[i].T;
    }
    vector<vector<int>> dp(n+1,vector<int>(k+1,1e9));
    dp[1][0]=0;
     bool updated;
    do {
        updated = false;
        for (int j = 0; j <= k; ++j) {        // Iterate all possible current costs
            for (int a = 1; a <= r; ++a) {    // Iterate all roads
                int s = roads[a].s;
                int e = roads[a].e;
                int L = roads[a].L;
                int T = roads[a].T;

                // Check if current state (s, j) is reachable and new cost is within budget
                if (j + T > k || dp[s][j] ==1e9) continue;

                // Update target state (e, j+T) if shorter path found
                if (dp[s][j] + L < dp[e][j + T]) {
                    dp[e][j + T] = dp[s][j] + L;
                    updated = true;
                }
            }
        }
    } while (updated);
int minl=1e9+5;
for(int i=0;i<=k;i++){
   minl=min(minl,dp[n][i]);
}
cout<<minl;
return 0;
}
```
# 问题 C: 生日蛋糕

题目描述
      
 要制作一个体积为 $N \pi$ 的 $M$ 层生日蛋糕，每层都是一个圆柱体。设从下往上数第 i（$1 \le i \le M$）层蛋糕是半径为 $R_i$、高度为 $H_i$ 的圆柱体。当 $i \lt M$ 时，要求 $R_i \gt R_i + 1$ 且 $H_i \gt H_i + 1$。由于要在蛋糕上抹奶油，为尽可能节约经费，希望蛋糕外表面（最下一层的下底面除外）的面积 $Q$ 最小。令 $Q = S \pi$，编程对给出的 $N$ 和 $M$，找出蛋糕的最佳制作方案（适当选取 $R_i$ 和 $H_i$ 的值，）使 $S$ 最小，并输出 $S$ 值。除 $Q$ 外，以上所有数据皆为正整数。 
 
  输入
        
 输入有两行，第一行为 $N$（$N \le 10000$），表示待制作的蛋糕体积为 $N \pi$；第二行为 $M$（$M \le 20$），表示蛋糕的层数为 $M$。        
 输出
        
   输出仅一行，是一个正整数 $S$（若无解，则 $S = 0$）。
 
                          


