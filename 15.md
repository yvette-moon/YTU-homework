## 题目描述
小虎是游戏中的一个国王，在他管理的国家中发行了很多不同面额的纸币，用这些纸币进行任意的组合可以在游戏中购买各种装备来提升自己。有一天，他突然很想知道这些纸币的组合不能表示的最小面额是多少，请聪明的你来帮助小虎来解决这个财政问题吧。

输入

输入包含多个测试用例，每组测试用例的第一行输入一个整数 $N$ $(N \le 100)$ 表示流通的纸币面额数量，第二行是 $N$ 个纸币的具体表示面额，取值 $[1, 100]$。

输出

对于每组测试用例，输出一个整数，表示已经发行的所有纸币都不能表示的最小面额（已经发行的每个纸币面额最多只能使用一次,但面值可能有重复）。

首先的想法是dfs组合出每种情况再找最小的不能表示的，但是复杂度太高了吧，
给出的题要求用动态规划，具体的实现方法就是
1.设置一个一维bool dp数组，dp[i]表示是否可以组成i金额。
2.初始化dp[0]=true
3.一个用一次，从后向前选择
4.状态转移：如果dp[j]==true,则可以叠加目标coin，叠加后的金额再设为true
最后找到最小的flase输出就好。

注意：考虑到都可以组成的情况，所以最后遍历的时候搜索到sum+1

```cpp
#include <bits/stdc++.h>
using namespace std;

int main() {
    int n;
    while (cin >> n && n != 0) {
        vector<int> coins(n);
        int sum = 0;
        for (int i = 0; i < n; i++) {
            cin >> coins[i];
            sum += coins[i];
        }

        vector<bool> dp(sum + 1, false);
        dp[0] = true;

        for (int i=0;i<n;i++) {
            int coin=coins[i];
            for (int j = sum - coin; j >= 0; j--) {
                if (dp[j])
                    dp[j + coin] = true;
            }
        }

        for (int i = 1; i <= sum+1; i++) {
            if (!dp[i]) {
                cout << i << endl;
                break;
            }
        }
    }
    return 0;
}
```
 题目描述
 Gustavo 知道如何计数，但他现在才刚刚学习如何写数字。他已经学会了数字$1$,$2$,$3$和$4$.但他还没有意识到$4$不同于$1$，所以他认为$4$只是另一种写法$1$.他正在玩他创造的一个小游戏：他用他知道的四位数字制作数字，并对它们的值求和。例如：$$132 = 1 + 3 + 2 = 6$$ $$112314 = 1 + 1 + 2 + 3 + 1 + 1 = 9$$（请记住，古斯塔沃是这么认为的$4 = 1$) Gustavo 现在想知道他可以创建多少个这样的数字，其和是一个数字$n$.为$n = 2$，他可以使$5$数字：$11$,$14$,$41$,$44$和$2$.（他知道如何数出 5 以上，只是不知道如何写。然而，他无法计算出这笔钱$n$大于$2$，并寻求您的帮助。      
 输入
 输入将由任意数量的整数组成$n$使得$1 \lt n \lt 1000$.您必须阅读，直到到达文件末尾。
 输出
 对于每个读取的整数，在一行上输出一个整数，说明 Gustavo 可以生成多少个数字，以使它们的数字之和等于$n$.考虑到答案可能很大，你只需要把答案 mod 打印出来就1000000009了。

```cpp
#include <iostream>
#include <vector>
using namespace std;

const int MOD = 1000000009;

int main() {
    ios::sync_with_stdio(false);
    cin.tie(0);
    
    // 最大n是999
    const int MAX_N = 1000;
    vector<long long> dp(MAX_N + 1, 0);
    dp[0] = 1;

    // 数位贡献：1（包括4）、2、3
    vector<int> digits = {1, 2, 3};

    // 完全背包构造dp
    for (int i = 1; i <= MAX_N; ++i) {
        for (int d : digits) {
            if (i >= d) {
                dp[i] = (dp[i] + dp[i - d]) % MOD;
            }
        }
    }

    // 读取多个输入直到EOF
    int n;
    while (cin >> n) {
        cout << dp[n] << '\n';
    }

    return 0;
}

```
## 题目描述
有一个由 $[1, 9]$ 组成的数字串，问如果将 $m$ 个加号插入到这个数字串中，在各种可能形成的表达式中，值最小的那个表达式的值是多少。例如，在 $1234$ 中摆放 $1$ 个加号，最好的摆法就是 $12+34$，和为 $36$。

输入

有不超过 $15$ 组数据。每组数据两行。第一行是整数 $m$，表示有 $m$ 个加号要放 $(0 \le m \le 17)$。第二行是若干个数字。数字总数 $n$ 不超过 $18$ 且 $m \le n-1$。

输出

对每组数据，输出最小加法表达式的值。

1.dp[i][j]表示前i个数字内加入j个加号之后得到的最小值。
2.初始化：dp[i][0]=前i个数字，最大设置为1e9。
3.状态转移：本身，或者前j~i-1个加j-1个加号再加剩下的数字的情况，所以要三层的for循环。
比如说 

2

123456

  |0     | 1                    | 2
  
0 |1e9   | 1e9                  |1e9

1 |1     | 1e9                  |

2 |12    | 3(1+2)               |

3 |123   | (1+23)/(12+3)/1e9    |

4 |1234

5 |12345

6 |123456

```cpp
#include <bits/stdc++.h>
using namespace std;
string a;
typedef long long ll;
ll sh(ll s,ll o){
    ll sum=0;
    for(ll k=s;k<=o;k++){
          sum=sum*10+(a[k]-'0');
    }
    return sum;
}
int main() {
    ll m;
    while(cin>>m){
    cin>>a;
    ll n=a.size();
    vector<vector<ll>> dp(n+1,vector<ll>(m+1,1e9));
    for(ll i=1;i<=n;i++){
        dp[i][0]=sh(0,i-1);
    }
    for(ll i=1;i<=n;i++){
        for(ll j=1;j<=m&&j<i;j++){
            for(ll k=j;k<i;k++)
            dp[i][j]=min(dp[i][j],dp[k][j-1]+sh(k,i-1));
        }
    }
    cout<<dp[n][m]<<endl;
}
    return 0;
}
```
## 问题 D: 动态规划进阶题目之滑雪

题目描述
      
 Michael喜欢滑雪百这并不奇怪， 因为滑雪的确很刺激。可是为了获得速度，滑的区域必须向下倾斜，而且当你滑到坡底，你不得不再次走上坡或者等待升降机来载你。Michael想知道载一个区域中最长的滑坡。区域由一个二维数组给出。数组的每个数字代表点的高度。下面是一个例子$$\begin{matrix}1 & 2 & 3 & 4 & 5 \\16 & 17 & 18 & 19 & 6 \\15 & 24 & 25 & 20 & 7 \\14 & 23 & 22 & 21 & 8 \\13 & 12 & 11 & 10 & 9\\\end{matrix}$$一个人可以从某个点滑向上下左右相邻四个点之一，当且仅当高度减小。在上面的例子中，一条可滑行的滑坡为 $24-17-16-1$。 当然 $25-24-23- \dots -3-2-1$ 更长。事实上，这是最长的一条。      
 输入
        
 输入的第一行表示区域的行数 $R$ 和列数 $C$ $(1 \le R, C \le 100)$。下面是 $R$ 行，每行有 $C$ 个整数，代表高度 $h$，$0 \le h \le 10000$。 
          
输出
        
 输出最长区域的长度。

四个方向搜索，很难不想到bfs'和dfs啊，你要找「从每个点出发能滑的最长路径」，这些路径可能互相重叠，所以直接 DFS 会重复计算。
所以用dp来记忆化
基本设计思路是，对每个点dfs搜索，每次只需要叠加记录过的dp就好。最后返回该点的dp值。用ans记录最大值。

拿例子来说：

5 5

1 2 3 4 5

16 17 18 19 6

15 24 25 20 7

14 23 22 21 8

13 12 11 10 9

如16，向下一路搜索，得到最长的数值为16，再搜索17，发现右侧16已经有值，并且是最大路径，直接相加记录返回。

```cpp
#include <bits/stdc++.h>
using namespace std;
int r,c;
int dx[]={-1,1,0,0};
int dy[]={0,0,-1,1};
int slip[105][105];
vector<vector<int>> dp;
int dfs(int x,int y){
    if(dp[x][y]!=0)
    return dp[x][y];
    int maxlen=1;
    for(int i=0;i<4;i++){
        int nx=x+dx[i];
        int ny=y+dy[i];
        if(nx>=0&&nx<r&&ny>=0&&ny<c&&slip[nx][ny]<slip[x][y]){
            maxlen=max(maxlen,dfs(nx,ny)+1);
        }
    }
    dp[x][y]=maxlen;
    return dp[x][y];
}
int main(){
    cin>>r>>c;
    for(int i=0;i<r;i++){
        for(int j=0;j<r;j++){
            cin>>slip[i][j];
        }
    }
    dp=vector<vector<int>> (r,vector<int>(c,0));
    int ans=-1e9;
    for(int i=0;i<r;i++){
        for(int j=0;j<r;j++){
            ans=max(ans,dfs(i,j));
        }
    }
    cout<<ans<<endl;
    return 0;
}
```
## 问题 E: 求子数组的最大和（动态规划）
题目描述
输入一个整型数组，数组里有正数也有负数。数组中连续的一个或多个整数组成一个子数组，每个子数组都有一个和。求所有子数组的和的最大值。

输入
一个整型数组。

输出
子数组的和的最大值。

```cpp
#include <bits/stdc++.h>
using namespace std;

int main() {
    vector<int> nums(50005);
    int len = 1;
    while (cin >> nums[len]) {
        len++;
    }
    // dp[i] 表示以第 i 个元素结尾的最大子数组和
    vector<int> dp(len + 1);
    int maxsum = nums[1]; // 初始化为第一个元素
    dp[1] = nums[1];
    for (int i = 2; i <= len; ++i) {
        // dp[i] 是 dp[i-1] 加上当前元素 nums[i] 或者当前元素 nums[i] 本身（如果前面的和为负数）
        dp[i] = max(dp[i-1] + nums[i], nums[i]);
        // 更新最大子数组和
        maxsum = max(maxsum, dp[i]);
    }
    cout << maxsum << endl;
    return 0;
}
```

## 题目描述
      
$N$ 个方盒摆成一排，每个方盒有自己的颜色，如图所示。连续摆放的同颜色方盒构成一个“大块”  玩家每次点击一个方盒，则该方盒所在大块就会消失。若消失的大块中共有 $k$ 个方盒，, 则玩家获得 $k \times k$ 个积分。请问：给定游戏开始时的状态，玩家可获得的最高积分是多少? 

 输入
        
 第一行是一个整数 $t$ $(1 \le t \le 15)$，表示共有多少组测试数据。每组测试数据又包括两行:首先是一个整数 $n$ $(1 \le n \le 200)$，表示共有多少个方盒; 其次包括 $n$ 个整数，表示每个方盒的 颜色。这些整数的取值范围是 $\left[1, n \right]$。
 
输出
        
对每组测试数据，分别输出该组测试数据的序号，以及玩家可以获得的最高积分。

          
🧩 题目简化理解
你有一排颜色盒子，比如：

复制代码
1 2 2 2 3 3 1
相邻相同颜色的盒子会被当成一块，一次可以把这一整块点掉。

点掉一个块，得分是：k * k（其中 k 是块中盒子的数量）。

你的目标是：选择删除顺序，使得最终得分最大。

🎯 核心难点
我们可以自由选择删除顺序，所以不能贪心！
比如你看到一块 3 个相同颜色的块，不能直接删，因为后面可能还有这个颜色，我们应该“合并远处的相同颜色”再一块删，分数更高。

💡 状态设计（3 维 DP）
我们用 dp[l][r][k] 表示：

在区间 [l, r] 内，假设右边有连续 k 个和 boxes[r] 一样颜色的盒子，获得的最大分数

为什么要加第三维 k？举个例子解释！

🎲 举个小例子：
假设你现在考虑区间：

csharp
复制代码
[1 2 3 2 2]，boxes[4] = 2
但在原始数组的右边，其实还有两个 2：

csharp
复制代码
[1 2 3 2 2 **2 2**]
我们希望把最右边这两个 2 一起合并起来再删除，这样打分更高，比如合并后是 4 个 2，得分就是 4 * 4 = 16，比 2*2 + 2*2 = 8 高很多！

所以我们需要知道：当前区间右边还有几个与 boxes[r] 相同的盒子（这个数量就是 k），并将其纳入得分计算。

🧠 状态转移
对于 dp[l][r][k]，我们有两种处理方式：

✅ 方式一：直接删除最后一段（r 和后面k个一样的）
cpp
复制代码
dp[l][r][k] = dp[l][r - 1][0] + (k + 1) * (k + 1);
意思是：先计算 [l, r-1] 的最优分，然后删除 r 和它右边连续的 k 个相同颜色，得分为 (k+1)^2

✅ 方式二：尝试合并前面的相同颜色块
我们枚举 i 满足 l <= i < r，如果 boxes[i] == boxes[r]：

cpp
复制代码
dp[l][r][k] = max(dp[l][r][k], dp[l][i][k+1] + dp[i+1][r-1][0]);
表示我们把 boxes[r] 和 boxes[i] 合并，处理区间 [i+1, r-1] 剩下的部分，然后再统一消掉这个大的块。

这个合并是这题最关键的优化。

🧾 初始条件
如果区间是只含一个元素：

cpp
复制代码
dp[l][r][k] = (k + 1)^2
比如 [3] 并且有后面2个相同颜色（k=2），得分是 (2+1)^2 = 9

✅ 总结思路
区间动态规划，必须三维来表达“右边合并块”的信息

两种决策：直接删 or 合并后删

递归 + 记忆化搜索避免重复计算

时间复杂度 O(n³)，但状态数不超过 200³ 可接受

🤖 想象一次递归过程：
比如输入：

复制代码
1 2 2 2 3 3 3 1
最优方式是：

先把中间 2 2 2 不动

把前后的 1 合并成一块 1 1 后再消掉

然后一起消掉 2 2 2 和 3 3 3
          
```cpp
#include <iostream>
#include <vector>
#include <cstring>
#include <algorithm>
using namespace std;

int dp[201][201][201];
int boxes[201];

// 记忆化搜索函数
int dfs(int l, int r, int k) {
    if (l > r) return 0;
    if (dp[l][r][k] != -1) return dp[l][r][k];

    // 先直接消除 r 位置和它后面 k 个同颜色的方块
    int res = dfs(l, r - 1, 0) + (k + 1) * (k + 1);

    // 尝试将 r 合并到前面某个相同颜色的 box 上
    for (int i = l; i < r; ++i) {
        if (boxes[i] == boxes[r]) {
            res = max(res, dfs(l, i, k + 1) + dfs(i + 1, r - 1, 0));
        }
    }

    return dp[l][r][k] = res;
}

int main() {
    int t;
    cin >> t;
    for (int case_num = 1; case_num <= t; ++case_num) {
        int n;
        cin >> n;
        for (int i = 0; i < n; ++i) {
            cin >> boxes[i];
        }

        memset(dp, -1, sizeof(dp));  // 重置记忆化数组
        int result = dfs(0, n - 1, 0);

        cout << "Case " << case_num << ": " << result << endl;
    }
    return 0;
}
```
