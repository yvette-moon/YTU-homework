# 问题 A: 城堡问题
**题目描述**
如图为一个地堡的地形图。编写一个程序，计算城堡一共有多少个房间，最大的房间有多大。城堡被分割成 $m \times n$ $(n \le 50, n \le 50)$ 个方块，每个方块可以有 $0 \sim 4$ 面墙。# 代表墙壁，| 和 - 都表示没有墙壁。不被墙分割的方块连在一起组成一个房间。城堡外围一圈都是墙。
  
 **输入**
        
  第一行是两个整数 $R$ 和 $C$，分别是南北向、东西向的方块数。
  接下来是一个 $R$ 行 $C$ 列的整数矩阵，每个整数 $p$ 描述一个方块（$0 \le p \le 50$）

如果用 $1$ 对应西墙，$2$ 对应北墙，$4$ 对应东墙，$8$ 对应南墙，则用来描述一个方块的整数，其值就是该方块周围每个墙所对应的数字之和。
例如，某方块有南墙和北墙，则描述它的整数就是 $2 + 8 = 10$。某方块四面都有墙，则描述它的整数就是 $1 + 2 + 4 + 8 = 15$。输入的数据保证城堡至少有两个房间。
  **输出**
城堡的房间数、城堡中最大房间所包括的方块数。

## 问题分析
看似还是一个bfs连通性问题，如果有图的话，无非是#围成的最大区域，但是不给图，给的数字，那我们看看能不能变成图
似乎有点难办
那我们想想核心的bfs怎么写
* 预备工作：定义方向数组dx dy，队列 储存当前坐标和标记，bool visit数组标记是否访问过，
* 初始化：把初始坐标载入，标记访问过
* 循环，当表不为空时，储存第一个，删除队列第一个，检查此时是否到达终点
* 在遍历这个节点的四个方向，检查边界以及连通性以及是否访问过，都符合，进队列
  
这个是求连续地块的思路，对应bfs那一篇的例题
要求最大的连续地块步骤会有所改动
* 准备工作，四个方向，visit标记，maxsize设置一个很小的数，队列
* main函数中，采用for循环遍历表中节点，如果是没被访问过的，进入比方说，返回地块大小值，与maxsize比较取大值
* bfs中int size=0，创建队列，初始化
* while（！q.empty)
* 储存现节点，出q队列，遍历四个方向，符合条件进队列，size++，标记为访问过

不过我们到底要怎么才能检验连通性？

那我们对于每一个点，无非就是判断能不能加入队列，只要有墙不就不能加了吗
那例如当我们访问3.4的上一个节点2.4时，判断3.4上面是否有墙，3.4如果对应的是7，7=1+2+4，上面有墙，pass
接下来我们来给出所以1 2 4 8的组合数

* 左方有墙的数：1，3，5，9，7，11，13，15
* 上方：2，3，6，10，7，11，14，15
* 右方：4，5，6，12，7，13，14，15
* 下方：8，9，10，12，14，13，11，15
```cpp
#include<bits/stdc++.h>
using namespace std;
int dx[]={1,-1,0,0};
int dy[]={0,0,-1,1};
int n,m;
 vector<vector<bool>> visit(50,vector<bool>(50,false));
int maxsize=-1e9;
vector<vector<int>> wall;
struct node{
    int x,y;
};
bool isvalid(int a,int ax,int ay){
    if(a==1)//上
    {
        if(wall[ax][ay]==2||wall[ax][ay]==3||wall[ax][ay]==6||wall[ax][ay]==10||wall[ax][ay]==7||wall[ax][ay]==11||wall[ax][ay]==14||wall[ax][ay]==15)
        return false;
        else return true;
    }
    else if(a==0)//xia
    {
        if(wall[ax][ay]==8||wall[ax][ay]==9||wall[ax][ay]==10||wall[ax][ay]==12||wall[ax][ay]==14||wall[ax][ay]==13||wall[ax][ay]==11||wall[ax][ay]==15)
        return false;
        else return true;
    }
   else  if(a==2)//zuo
    {
        if(wall[ax][ay]==1||wall[ax][ay]==3||wall[ax][ay]==5||wall[ax][ay]==9||wall[ax][ay]==7||wall[ax][ay]==11||wall[ax][ay]==13||wall[ax][ay]==15)
        return false;
        else return true;
    }
    else if(a==3)
    {
        if(wall[ax][ay]==4||wall[ax][ay]==5||wall[ax][ay]==6||wall[ax][ay]==12||wall[ax][ay]==7||wall[ax][ay]==13||wall[ax][ay]==14||wall[ax][ay]==15)
        return false;
        else return true;
    }
    return false;
}
int bfs(int startx,int starty){
     int size=0;
     queue<node> q;
     q.push({startx,starty});
     visit[startx][starty]=true;
     size++;
     while(!q.empty()){
           node current=q.front();
           q.pop();
           for(int i=0;i<4;i++){
            int nx=current.x+dx[i];
            int ny=current.y+dy[i];
            if(nx>=0&&nx<n&&ny>=0&&ny<m&&!visit[nx][ny]&&isvalid(i,current.x,current.y)){
                q.push({nx,ny});
                visit[nx][ny]=true;
                size++;
            }
           }
     }
     return size;
}
int main(){
    cin>>n>>m;
    int count=0;
    wall.resize(n,vector<int>(m));
    for(int i=0;i<n;i++){
        for(int j=0;j<m;j++){
            cin>>wall[i][j];
        }
    }
    for(int i=0;i<n;i++){
        for(int j=0;j<m;j++){
            if(visit[i][j]==false)
           {
                count++;
             maxsize=max(maxsize,bfs(i,j));
            }
        }
    }
    cout<<count<<endl<<maxsize<<endl;
    return 0;
}
```
基本是按照上面的思路写的，但是类bfs可能是实在不熟悉所以写的很慢还有错误，甚至访问后visit没标记。。。
# 问题 B: ROADS
**题目描述**
有 $N$ 个城市，编号为 $1$ ~ $N$。城市间有 $N$ 条单向道路，每条道路连接两个城市，有长度和过路费两个属性。Bob 只有 $K$ 块钱，他想从城市 $1$ 走到城市 $N$。问最短需要走多长的路。如果到不了 $N$，输出 $-1$。其中，$2 <+ N<=100$；$0 <= K <= 10000$；$1 \le R \le 10000$；每条路的长度为 $L$，$1 \le L \le 100$；每条路的过路费为 $T$，$0 \le T \le 100$。

输入
        
第一行是 $K$，第二行是 $N$，第三行是 $R$。接下来有 $R$ 行，每行有 $4$ 个整数 $s, e, L, T$，表示从城市 $s$ 到城市 $e$ 有一条单向路（可以沿该路从 $s$ 走到 $e$，但不能沿该路从 $e$ 走到 $s$），其长度是 $L$，过路费是 $T$。  

 输出
        
 只有一行，就是问题答案。        

 ## 问题分析
 
                          


